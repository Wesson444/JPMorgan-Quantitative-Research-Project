# -*- coding: utf-8 -*-
"""JP-Morgan-Quantitive-Research-Certificate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WxE9t8X9Ebc6UYd5pB7Y_sk0UcNC6G3i

# Task 1

预测石油天然气的价格

virtualize data
"""

import pandas as pd
import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import itertools

data = pd.read_csv('Nat_Gas.csv', parse_dates=['Dates'], index_col='Dates', dayfirst=True)
data.rename(columns={'Prices': 'Price'}, inplace=True)
data.sort_index(inplace=True)

data.head()

print("\n", data['Price'].describe())

plt.figure(figsize=(12, 6))
plt.plot(data.index, data['Price'], marker='o', linestyle='-') # 直接使用data.index作为X轴
plt.title('Natural Gas Price Over Time')
plt.xlabel('Dates')
plt.ylabel('Prices')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

"""there are seasonal patterns in these gas prices, which should be taken in consideration in the prediction process.

"""

from statsmodels.tsa.seasonal import seasonal_decompose
seasonal_decompose(data['Price'], model='multiplicative', period=12).plot()
plt.show()


data['Month'] = data.index.month_name()
month_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

plt.figure(figsize=(9, 5))
sns.boxplot(x='Month', y='Price', data=data, order=month_order)
plt.xticks(rotation=45)
plt.show()

# search for best sarima model to predict
p = d = q = range(0, 2)
pdq = list(itertools.product(p, d, q))
seasonal_pdq = [(x[0], x[1], x[2], 12) for x in pdq]

best_aic = float("inf")
best_params = None
best_seasonal_params = None
best_model_results = None

for param in pdq:
  for param_seasonal in seasonal_pdq:
    try:
      mod = sm.tsa.SARIMAX(data['Price'],
                           order=param,
                           seasonal_order=param_seasonal)
      results = mod.fit(disp=False)
      if results.aic < best_aic:
        best_aic = results.aic
        best_params = param
        best_seasonal_params = param_seasonal
        best_model_results = results
    except:
      continue

print(f"\n best model is SARIMA{best_params}x{best_seasonal_params} - AIC:{best_aic:.2f}")

best_model_results.summary()

#prediction
forecast_object = best_model_results.get_forecast(steps=12)
future_forecast_values = forecast_object.predicted_mean

from pandas.tseries.offsets import DateOffset
last_date = data.index[-1]
future_dates = pd.date_range(start=last_date + DateOffset(months=1), periods=12, freq='M')

future_forecast = pd.Series(future_forecast_values.values, index=future_dates)



from pandas.tseries.offsets import DateOffset
last_date = data.index[-1]
future_dates = pd.date_range(start=last_date + DateOffset(months=1), periods=12, freq='M')

future_prices = future_forecast.values
future_forecast = pd.Series(future_prices, index=future_dates)

# a. 处理历史数据：将原始月度数据插值为每日数据
daily_historical_data = data.resample('D').asfreq().interpolate(method='linear')

# b. 处理未来数据：将月度预测数据插值为每日数据
last_historical_point = data.tail(1)
monthly_future_points = pd.concat([last_historical_point, pd.DataFrame({'Price': future_forecast})])
daily_future_data = monthly_future_points.resample('D').asfreq().interpolate(method='linear')

# c. 合并历史和未来每日数据
final_daily_prices_series = pd.concat([
    daily_historical_data['Price'],
    daily_future_data['Price'].iloc[1:]
])

# d. 创建函数: 输入日期输出价格
def estimate_price(date: str):
  target_date = pd.to_datetime(date, dayfirst=True) # 同样使用 dayfirst=True
  if target_date in final_daily_prices_series.index:
    price = final_daily_prices_series[target_date]
    return price
  else:
    min_date = final_daily_prices_series.index.min().strftime('%Y-%m-%d')
    max_date = final_daily_prices_series.index.max().strftime('%Y-%m-%d')
    return f"error: not valid date, please make sure your input between {min_date} and {max_date}。"

# e. 输出结果，格式化为最终需要的DataFrame（两列：Dates, Prices）
final_df = final_daily_prices_series.reset_index()
final_df.columns = ['Dates', 'Prices']

# f. 导出到CSV文件
output_filename = 'daily_natural_gas_prices_full.csv'
final_df.to_csv(output_filename, index=False, float_format='%.3f')

"""# Task 2

对仓储合同进行定价

price difference * principal - storage fee - injection/withdrawal fee - transporting fee = contract price

The concept is simple: any trade agreement is as valuable as the price you can sell minus the price at which you are able to buy. Any cost incurred as part of executing this agreement is also deducted from the overall value. So, for example, if I can purchase a million MMBtu of natural gas in summer at $2/MMBtu, store this for four months, and ensure that I can sell the same quantity at $3/MMBtu without incurring any additional costs, the value of this contract would be ($3-$2) *1e6 = $1million. If there are costs involved, such as having to pay the storage facility owner a fixed fee of $100K a month, then the 'value' of the contract, from my perspective, would drop by the overall rental amount to $600K. Another cost could be the injection/withdrawal cost, like having to pay the storage facility owner $10K per 1 million MMBtu for injection/withdrawal, then the price will further go down by $10K to $590K. Additionally, if I am supposed to foot a bill of $50K each time for transporting the gas to and from the facility, the cost of this contract would fall by another $100K. Think of the valuation as a fair estimate at which both the trading desk and the client would be happy to enter into the contract.
"""





