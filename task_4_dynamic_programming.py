# -*- coding: utf-8 -*-
"""Task 4 -dynamic programming.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1REoJDKUae2ACU3t0qylrpWu45OujoQhw

2 ways to generate fico buckets
"""

import pandas as pd
import numpy as np

#method 1 :using MSE to generate buckets

# func 1 : calculate mse of bucket
def calculate_mse(values):
    """ calculate mse of the fico bucket """
    if len(values) == 0:
        return 0
    mean = np.mean(values)
    return np.sum((values - mean) ** 2)

# func 2 : find optimal buckets
def find_optimal_binning_mse(df: pd.DataFrame, num_bins: int):
    """
    using dynamic programming to minimize mse of fico bucket

    we got df: 'fico score'
    num_bin: goal of number of buckets

    return:
    list: best buckets boundary

    """
    data = df[['fico_score']].copy()
    data.sort_values('fico_score', inplace=True)
    data.reset_index(drop=True, inplace=True)

    n_points = len(data)

    mse_cache = {}
    for i in range(n_points):
        for j in range(i, n_points):
            mse_cache[(i, j)] = calculate_mse(data.loc[i:j, 'fico_score'].values)

    dp = np.full((n_points + 1, num_bins + 1), np.inf)
    path = np.zeros((n_points + 1, num_bins + 1), dtype=int)

    dp[0][0] = 0

    for j in range(1, num_bins + 1):
        for i in range(1, n_points + 1):
            for k in range(i):
                mse_cost = mse_cache.get((k, i-1), np.inf)
                current_mse = dp[k][j-1] + mse_cost
                if current_mse < dp[i][j]:
                    dp[i][j] = current_mse
                    path[i][j] = k

    boundaries = []
    current_pos = n_points
    for j in range(num_bins, 0, -1):
        last_pos = path[current_pos][j]
        if last_pos != 0:
            boundary_score = data.loc[last_pos - 1, 'fico_score']
            boundaries.append(boundary_score)
        current_pos = last_pos

    boundaries.reverse()
    return boundaries

def calculate_log_likelihood(k, n):
    if k == 0 or k == n:
        return 0
    p = k / n
    return k * np.log(p) + (n - k) * np.log(1 - p)

def find_optimal_binning_supervised(df: pd.DataFrame, num_bins: int):

    data = df[['fico_score', 'default']].copy()
    data.sort_values('fico_score', inplace=True)
    data.reset_index(drop=True, inplace=True)

    n_points = len(data)


    dp = np.full((n_points + 1, num_bins + 1), -np.inf)
    path = np.zeros((n_points + 1, num_bins + 1), dtype=int)
    dp[0][0] = 0

    for j in range(1, num_bins + 1):
        for i in range(1, n_points + 1):
            for k in range(i):
                n_ij = data.loc[k:i-1, 'fico_score'].count()
                k_ij = data.loc[k:i-1, 'default'].sum()
                if n_ij == 0: continue

                log_like = calculate_log_likelihood(k_ij, n_ij)
                current_log_like = dp[k][j-1] + log_like
                if current_log_like > dp[i][j]:
                    dp[i][j] = current_log_like
                    path[i][j] = k

    boundaries = []
    current_pos = n_points
    for j in range(num_bins, 0, -1):
        last_pos = path[current_pos][j]
        if last_pos != 0:
            boundary_score = data.loc[last_pos - 1, 'fico_score']
            boundaries.append(boundary_score)
        current_pos = last_pos

    boundaries.reverse()
    return boundaries
